# 소유권?

프로그램의 메모리 관리법, 기존 프로그래밍 언어는

1. 가비지 컬렉션으로 더이상 사용하지 않는 메모리를 정기적으로 찾는 방식
2. 프로그래머가 명시하는 방식

하지만 rust는 제 3의 방식을 채택했다.

1. 소유권이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리, 이 규칙중 하나라도 위반하면 프로그램은 컴파일 되지 않는다

# 소유권 규칙

- 가각의 값은 owner가 정해져있다
- 한 값의 owner는 동시에 여럿 존재 할 수 없다
- owner가 스코프 밖으로 벗어날때, 값은 버려진다(dropped)

# 변수의 스코프

```rust
{                      // s는 아직 선언되지 않아서 여기서는 유효하지 않습니다
    let s = "hello";   // 이 지점부터 s가 유효합니다

    // s로 어떤 작업을 합니다
}                      // 이 스코프가 종료되었고, s가 더 이상 유효하지 않습니다

```

1. `s`가 스코프 *내에* 나타나면 유효합니다.
2. 유효기간은 스코프 *밖으로* 벗어나기 전까지입니다.

# String 타입

앞서 다룬 타입들은 명확한 크기를 가지고 있어, 전부 스택에 저장되고 스코프를 벗어날때 제거되며, 코드의 다른 쪽에서 별도의 스코프내에서 같은 값을 사용하려 할때 새 독립적인 인스턴스를 빠르고 간단하게 만들어낼수있다.

- 여태 보아온 문자열은 코드 내에 하드 코딩하는 <문자열 리터럴> 이였다.
- 하지만 문자열 리터럴은 불변성을 지니기에 변경할수 없다
- 프로그램에 필요한 모든 문자열을 우리가 프로그래밍 하는 시점에 알 수 없다.

즉, 사용자한테 문자열을 입력 받아 저장하는 기능등을 만들어야 하는 상황에서는 하드 코딩인 <문자열 리터럴>을 쓸수 없다.

```rust
let s = String::from("hello");
```

그래서 `String type`을 제공한다.

이중 콜론 `::`은 함수를 사용할때 string_from 같은 함수명을 사용하지 않고 String 타입의 있는 특정된 from 함수라는 것을 지정할수 있게 하는 네임스페이스 연산자이다 (js의 프로토타입과 유사)

```rust
 let mut s = String::from("hello");

  s.push_str(", world!"); // push_str()이 문자열에 리터럴을 추가합니다

  println!("{}", s); // 이 줄이 `hello, world!`를 출력합니다
```

# 메모리와 할당

문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행파일에 하드코딩됩니다.

반면 `String` 타입은 힙에 메모리를 할당하는 방식을 사용하기 때문에 텍스트 내용 및 크기를 변경할 수 있습니다. 하지만 이는 다음을 의미하기도 합니다:

- 실행 중 메모리 할당자로부터 메모리를 요청해야 합니다.
- `String` 사용을 마쳤을 때 메모리를 해제할 (즉, 할당자에게 메모리를 반납할) 방법이 필요합니다.

“실행 중 메모리 할당자로부터 메모리를 요청해야 합니다.”은 앞서 `Strng::from`으로 호출할때 이미 필요한 만큼 메모리를 요청하도록 구현되어있다

하지만 두번째는 다르다.

문자열 리터럴을 `String`으로 바꿔보자면

```rust

    {
        let s = String::from("hello"); // s는 이 지점부터 유효합니다

        // s를 가지고 무언가 합니다
    }                                  // 이 스코프가 종료되었고, s는 더 이상
                                       // 유효하지 않습니다.
```

기존 프로그래밍 방식과 다르가 s가 스코프 밖으로 벗어날떄 rust는 `drop`이라는 특별한 함수를 호출한다.

위의 경우 `String` 개발자가 작성한 메모리 해제 코드가 실행되겠죠. `drop`은 닫힌 중괄호 `}`가 나타나는 지점에서 자동으로 호출된다.

이 패턴은 러스트 코드를 작성하는 데 깊은 영향을 미칩니다. 지금은 단순해 보이지만, 힙 영역을 사용하는 변수가 많아져 상황이 복잡해지면 코드가 예기치 못한 방향으로 동작할 수도 있죠. 그러면 지금부터 그런 복잡한 상황들을 더 알아보도록 합시다.

# 변수와 데이터 간 상호작용 방식 : 이동

러스트에서는 동일한 데이터에 여러 변수가 서로 다른 방식으로 상호작용할 수 있습니다. 정수형을 이용한 예제로 살펴보겠습니다.

```rust

    let x = 5;
    let y = x;

    // String 타입 사용시
    let s1 = String::from("hello");
    let s2 = s1;
```

![image](https://github.com/NooChuHan/Rust_is_comming/assets/79236624/7d8080e8-85ba-4cff-a473-98c2d2088e44)

처음 코드와 다르게 s1 변수는 값을 위한 메타 데이터를 가지고 있고, 이는 스택에 저장된다, 값은 힙 메모리에 들어가있는데.

복사를 하게 된다면

![image](https://github.com/NooChuHan/Rust_is_comming/assets/79236624/14e087db-14d6-414e-b018-562c430322bc)

이처럼 참조값이 저장되며, 값이 복사되지는 않는다. 많약 값이 복사가 된다면

![image](https://github.com/NooChuHan/Rust_is_comming/assets/79236624/02b61b3c-05b7-414a-bff9-3f55a655c784)

힙 데이터가 커질수록 `s1=s2`연산이 굉장히 느려질것이다.

그렇다면, 두 포인터가 같은 곳을 가리킬 경우에는 GC가 발생하면 어떻게 될까? `s2`, `s1`이 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 ***중복 해제 (double free)* 에러**가 발생할 겁니다. 이는 메모리 안정성 버그 중 하나이며, 보안을 취약하게 만드는 메모리 손상의 원인이다.

메모리 안정성을 보장하기 위해서, 러스트는 `let s2 = s1;` 라인 뒤로는 `s1`이 더 이상 유효하지 않다고 판단합니다. 이로써 러스트는 `s1`이 스코프를 벗어나더라도 아무것도 해제할 필요가 없어집니다. `s2`가 만들어진 이후에 `s1`을 사용하는 경우 어떤 일이 생기는지 확인해 보면, 작동하지 않음을 알 수 있습니다:

```rust

    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
```

![image](https://github.com/NooChuHan/Rust_is_comming/assets/79236624/2c2845fd-bb8a-4dce-9cba-3dd356b09483)

여러분이 다른 프로그래밍 언어에서 *얕은 복사 (shallow copy)*, *깊은 복사 (deep copy)* 라는 용어를 들어보셨다면, 힙 데이터를 복사하지 않고 포인터, 길이, 용량 값만 복사하는 것을 얕은 복사라고 생각하셨을 수도 있지만,

러스트에서는 **기존의 변수를 무효화하기 때문에 이를 얕은 복사가 아닌 *이동 (move)* 이라 하고, 앞선 코드는 `s1`이 `s2`로 *이동되었다*라고 표현합니다.**

!https://doc.rust-kr.org/img/trpl04-04.svg

심지어 러스트는 절대 자동으로 ‘깊은’ 복사로(값을 복사) 데이터를 복사하는 일이 없다

# 변수와 데이터 간 상호 작용 방식 : 클론

만약 깊은 복사를 하고 싶다면 `clone` 이라는 공용 메서드를 사용한다

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);

```

# 스택에만 저장되는 데이터 : 복사

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

스택은 복사본을 빠르게 만들기 때문에, 굳이 무효화 할 필요가 없다. 스택에서는 값이 복사된다

물론 스택에 저장되는 타입에 달아 놓을수있는 `copy` 트레이드가 있지만, 나중에 배운다

# 소유권과 함수

함수로 값을 전달하는 매커니즘은 변수에 값을 대입할 때와 유사하다, 함수에 변수를 전달하면 대입 연산과 마찬가지로 이동이나 복사가 일어나기 때문

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어옵니다

    takes_ownership(s);             // s의 값이 함수로 이동됩니다...
                                    // ... 따라서 여기서는 더 이상 유효하지 않습니다

    let x = 5;                      // x가 스코프 안으로 들어옵니다

    makes_copy(x);                  // x가 함수로 이동될 것입니다만,
                                    // i32는 Copy이므로 앞으로 계속 x를
                                    // 사용해도 좋습니다

} // 여기서 x가 스코프 밖으로 벗어나고 s도 그렇게 됩니다. 그러나 s의 값이 이동되었으므로
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어옵니다
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어나고 `drop`이 호출됩니다.
  // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어옵니다
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어납니다. 별다른 일이 발생하지 않습니다.
```

# 반환 값과 스코프

값은 반환 하는 과정에서도 이동이 된다

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership이 자신의 반환 값을 s1로
                                        // 이동시킵니다

    let s2 = String::from("hello");     // s2가 스코프 안으로 들어옵니다

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back로 이동되는데,
                                        // 이 함수 또한 자신의 반환 값을 s3로
                                        // 이동시킵니다
} // 여기서 s3가 스코프 밖으로 벗어나면서 버려집니다. s2는 이동되어서 아무 일도
  // 일어나지 않습니다. s1은 스코프 밖으로 벗어나고 버려집니다.

fn gives_ownership() -> String {             // gives_ownership은 자신의 반환 값을
                                             // 자신의 호출자 함수로 이동시킬
                                             // 것입니다

    let some_string = String::from("yours"); // some_string이 스코프 안으로 들어옵니다

    some_string                              // some_string이 반환되고
                                             // 호출자 함수 쪽으로
                                             // 이동합니다
}

// 이 함수는 String을 취하고 같은 것을 반환합니다
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로
                                                      // 들어옵니다

    a_string  // a_string이 반환되고 호출자 함수 쪽으로 이동합니다
}
```

러스트에서는 튜플을 사용하여 여러 값을 반환하는 것이 가능하다

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()은 String의 길이를 반환합니다

    (s, length)
}
```

하지만 너무 거추장스럽다 rust의 reference라는 기능을 참고하면 좋다
