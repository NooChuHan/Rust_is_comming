# 11.3 Hash Map

# ì •ë¦¬

### HashMapì˜ í•µì‹¬ ë‚´ìš© ì •ë¦¬

### ê¸°ë³¸ ì‘ë™ ë°©ì‹

- HashMapì€ í‚¤ë¥¼ í†µí•´ ê°’ì„ ì €ì¥í•˜ë©°, í•´ì‹œ ë§µì€ ì‚¬ë¶„ë©´ íƒì‚¬ì™€ SIMD ì¡°íšŒë¥¼ ì‚¬ìš©.
- ê¸°ë³¸ í•´ì‹± ì•Œê³ ë¦¬ì¦˜ì€ í˜„ì¬ SipHash 1-3, í–¥í›„ ë³€ê²½ ê°€ëŠ¥ì„± ìˆìŒ.

### HashMap í‚¤ì˜ ìš”êµ¬ ì‚¬í•­

- `Eq`ì™€ `Hash` íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ëª¨ë“  íƒ€ì…ì´ í‚¤ë¡œ ì‚¬ìš© ê°€ëŠ¥.
- ì˜ˆì‹œ:
  - `bool`, `int`, `uint` ë° ëª¨ë“  ë³€í˜•
  - `String`ê³¼ `&str`
  - `f32`ì™€ `f64`ëŠ” í•´ì‹±ì„ ì§€ì›í•˜ì§€ ì•ŠìŒ.

### ìš©ëŸ‰ ê´€ë¦¬

- HashMapì€ ë²¡í„°ì²˜ëŸ¼ í¬ê¸°ë¥¼ ì¡°ì ˆí•  ìˆ˜ ìˆìœ¼ë©°, ì—¬ìœ  ê³µê°„ì´ ë§ì„ ë•Œ ì¶•ì†Œí•  ìˆ˜ ìˆìŒ.
- `HashMap::with_capacity(uint)`ë¡œ íŠ¹ì • ì´ˆê¸° ìš©ëŸ‰ ì„¤ì • ê°€ëŠ¥.
- `HashMap::new()`ë¡œ ê¸°ë³¸ ì´ˆê¸° ìš©ëŸ‰ì˜ HashMap ìƒì„± ê°€ëŠ¥.

### ì†Œìœ ê¶Œ

- `i32` ê°™ì€ `Copy` íŠ¸ë ˆì´íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” íƒ€ì…ì€ ê°’ì´ ë³µì‚¬ë¨.
- `String` ê°™ì€ ì†Œìœ ê¶Œì´ ìˆëŠ” ê°’ì€ HashMapìœ¼ë¡œ ì´ë™ë˜ì–´ HashMapì´ ì†Œìœ ìê°€ ë¨.

### ì„œë“œ íŒŒí‹° í•´ì‹œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©

- ì„±ëŠ¥ ìš”êµ¬ë¥¼ ì¶©ì¡±í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš° crates.ioë‚˜ github.comì—ì„œ ëŒ€ì²´ í•´ì‹œ í•¨ìˆ˜ ì‚¬ìš© ê°€ëŠ¥.
- ì˜ˆì‹œ:
  ```rust
  use std::hash::BuildHasherDefault;
  use std::collections::HashMap;
  use twox_hash::XxHash64;

  let mut hash: HashMap<_, _, BuildHasherDefault<XxHash64>> = Default::default();
  hash.insert(42, "the answer");
  assert_eq!(hash.get(&42), Some(&"the answer"));

  ```

## 1. [Basic Operations](https://practice.course.rs/collections/hashmap.html#basic-operations)

1. ğŸŒŸğŸŒŸ

```rust

// FILL in the blanks and FIX the errors
use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert("Sunface", 98);
    scores.insert("Daniel", 95);
    scores.insert("Ashley", 69.0);
    scores.insert("Katie", "58");

    // Get returns an Option<&V>
    let score = scores.get("Sunface");
    assert_eq!(score, Some(98));

    if scores.contains_key("Daniel") {
        // Indexing returns a value V
        let score = scores["Daniel"];
        assert_eq!(score, __);
        scores.remove("Daniel");
    }

    assert_eq!(scores.len(), __);

    for (name, score) in scores {
        println!("The score of {} is {}", name, score);
    }
}
```

```rust
// FILL in the blanks and FIX the errors
use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert("Sunface", 98);
    scores.insert("Daniel", 95);
    scores.insert("Ashley", 69);
    scores.insert("Katie", 58);

    // Get returns an Option<&V>
    let score = scores.get("Sunface");
    assert_eq!(score.copied(), Some(98));

    if scores.contains_key("Daniel") {
        // Indexing returns a value V
        let score = scores["Daniel"];
        assert_eq!(score, 95);
        scores.remove("Daniel");
    }

    assert_eq!(scores.len(), 3);

    for (name, score) in scores {
        println!("The score of {} is {}", name, score);
    }
}
```

1. Hashmapì€ ëª¨ë‘ ê°™ì€ íƒ€ì…ì´ì—¬ì•¼í•œë‹¤
2. get ë©”ì„œë“œëŠ” ê°’ì„ ì°¾ì§€ ëª»í•˜ëŠ” ê°€ëŠ¥ì„±ì´ ìˆê¸°ì— Option<&V> íƒ€ì…ì„ ë°˜í™˜í•œë‹¤ â‡’ copiedë¥¼ í†µí•´ì„œ ë‚´ë¶€ì˜ ê°’ì´ ì°¸ì¡°ìì„ë•Œ, í•´ë‹¹ ì°¸ì¡°ì ê°’ì„ ë³µì‚¬í•˜ê²Œ ë§Œë“¤ì–´ì•¼í•¨

### 2. ğŸŒŸğŸŒŸ

```rust

use std::collections::HashMap;
fn main() {
    let teams = [
        ("Chinese Team", 100),
        ("American Team", 10),
        ("France Team", 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &teams {
        teams_map1.insert(team.0, team.1);
    }

    // IMPLEMENT team_map2 in two ways
    // Tips: one of the approaches is to use `collect` method
    let teams_map2...

    assert_eq!(teams_map1, teams_map2);

    println!("Success!");
}

// =>
use std::collections::HashMap;

fn main() {
    let teams = [
        ("Chinese Team", 100),
        ("American Team", 10),
        ("France Team", 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &teams {
        teams_map1.insert(team.0, team.1);
    }

    let teams_map2: HashMap<_, _> = teams.iter().cloned().collect();

    assert_eq!(teams_map1, teams_map2);

    println!("Success!");
}

```

- `teams.iter()`ëŠ” `teams` ë°°ì—´ì˜ ì´í„°ë ˆì´í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
- `cloned()` ë©”ì„œë“œëŠ” ì´í„°ë ˆì´í„°ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì–•ì€ ë³µì‚¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” `(íŒ€ ì´ë¦„, ì ìˆ˜)` ìŒì„ ë³µì‚¬í•©ë‹ˆë‹¤.
- `collect()` ë©”ì„œë“œëŠ” ì´í„°ë ˆì´í„°ë¥¼ ìˆ˜ì§‘í•˜ì—¬ `HashMap`ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. íƒ€ì… ì–´ë…¸í…Œì´ì…˜ `HashMap<_, _>`ì€ Rustì—ê²Œ ì ì ˆí•œ íƒ€ì…ì„ ì¶”ë¡ í•˜ë„ë¡ ë•ìŠµë‹ˆë‹¤.

### 3. ğŸŒŸğŸŒŸ

```rust

// FILL in the blanks
use std::collections::HashMap;
fn main() {
    // Type inference lets us omit an explicit type signature (which
    // would be `HashMap<&str, u8>` in this example).
    let mut player_stats = HashMap::new();

    // Insert a key only if it doesn't already exist
    player_stats.entry("health").or_insert(100);

    assert_eq!(player_stats["health"], __);

    // Insert a key using a function that provides a new value only if it
    // doesn't already exist
    player_stats.entry("health").or_insert_with(random_stat_buff);
    assert_eq!(player_stats["health"], __);

    // Ensures a value is in the entry by inserting the default if empty, and returns
    // a mutable reference to the value in the entry.
    let health = player_stats.entry("health").or_insert(50);
    assert_eq!(health, __);
    *health -= 50;
    assert_eq!(*health, __);

    println!("Success!");
}

fn random_stat_buff() -> u8 {
    // Could actually return some random value here - let's just return
    // some fixed value for now
    42
}

=>

// FILL in the blanks
use std::collections::HashMap;
fn main() {
    // Type inference lets us omit an explicit type signature (which
    // would be `HashMap<&str, u8>` in this example).
    let mut player_stats = HashMap::new();

    // Insert a key only if it doesn't already exist
    player_stats.entry("health").or_insert(100);

    assert_eq!(player_stats["health"], 100);

    // Insert a key using a function that provides a new value only if it
    // doesn't already exist
    player_stats.entry("health").or_insert_with(random_stat_buff);
    assert_eq!(player_stats["health"], 100);

    // Ensures a value is in the entry by inserting the default if empty, and returns
    // a mutable reference to the value in the entry.
    let health = player_stats.entry("health").or_insert(50);
    assert_eq!(health, &100);
    *health -= 50;
    assert_eq!(*health, 50);

    println!("Success!");
}

fn random_stat_buff() -> u8 {
    // Could actually return some random value here - let's just return
    // some fixed value for now
    42
}
```

- `or_insert`: ê°’ì´ ì§ì ‘ ì£¼ì–´ì§‘ë‹ˆë‹¤. í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ ë°”ë¡œ í‰ê°€ë©ë‹ˆë‹¤.
- `or_insert_with`: ê°’ì´ í•¨ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. í•„ìš”í•  ë•Œë§Œ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ì–´ ê°’ì„ í‰ê°€í•©ë‹ˆë‹¤.

## 2. [**Requirements of HashMap key**](https://practice.course.rs/collections/hashmap.html#requirements-of-hashmap-key)

```rust

// FIX the errors
// Tips: `derive` is usually a good way to implement some common used traits
use std::collections::HashMap;

struct Viking {
    name: String,
    country: String,
}

impl Viking {
    /// Creates a new Viking.
    fn new(name: &str, country: &str) -> Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    // Use a HashMap to store the vikings' health points.
    let vikings = HashMap::from([
        (Viking::new("Einar", "Norway"), 25),
        (Viking::new("Olaf", "Denmark"), 24),
        (Viking::new("Harald", "Iceland"), 12),
    ]);

    // Use derived implementation to print the status of the vikings.
    for (viking, health) in &vikings {
        println!("{:?} has {} hp", viking, health);
    }
}

=>

use std::collections::HashMap;

// í•„ìš”í•œ íŠ¸ë ˆì´íŠ¸ë“¤ì„ ìë™ìœ¼ë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•´ derive ì†ì„±ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
#[derive(Hash, Eq, PartialEq, Debug)]
struct Viking {
    name: String,
    country: String,
}

impl Viking {
    /// ìƒˆë¡œìš´ Vikingì„ ìƒì„±í•©ë‹ˆë‹¤.
    fn new(name: &str, country: &str) -> Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    // Vikingì˜ ê±´ê°• í¬ì¸íŠ¸ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ HashMapì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    let vikings = HashMap::from([
        (Viking::new("Einar", "Norway"), 25),
        (Viking::new("Olaf", "Denmark"), 24),
        (Viking::new("Harald", "Iceland"), 12),
    ]);

    // íŒŒìƒëœ êµ¬í˜„ì„ ì‚¬ìš©í•˜ì—¬ ë°”ì´í‚¹ë“¤ì˜ ìƒíƒœë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
    for (viking, health) in &vikings {
        println!("{:?} has {} hp", viking, health);
    }
}

```

- `#` â‡’ ì–´íŠ¸ë¦¬ë·°íŠ¸ : Rustì˜ ì–´íŠ¸ë¦¬ë·°íŠ¸ëŠ” ë©”íƒ€ë°ì´í„°ë¡œ, ì½”ë“œì— ëŒ€í•œ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•˜ë©° ì»´íŒŒì¼ëŸ¬ê°€ íŠ¹ì • ë°©ì‹ìœ¼ë¡œ ë™ì‘í•˜ë„ë¡ í•©ë‹ˆë‹¤. `#[derive(...)]`ëŠ” ì»´íŒŒì¼ëŸ¬ì—ê²Œ íŠ¹ì • íŠ¸ë ˆì´íŠ¸ë“¤ì„ êµ¬ì¡°ì²´ë‚˜ ì—´ê±°í˜•ì— ìë™ìœ¼ë¡œ êµ¬í˜„í•˜ë¼ê³  ì§€ì‹œí•˜ëŠ” ì–´íŠ¸ë¦¬ë·°íŠ¸ì…ë‹ˆë‹¤

## 3. [**Capacity**](https://practice.course.rs/collections/hashmap.html#capacity)

```rust

use std::collections::HashMap;
fn main() {
    let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);
    map.insert(1, 2);
    map.insert(3, 4);
    // Indeed ,the capacity of HashMap is not 100, so we can't compare the equality here.
    assert!(map.capacity() >= 100);

    // Shrinks the capacity of the map with a lower limit. It will drop
    // down no lower than the supplied limit while maintaining the internal rules
    // and possibly leaving some space in accordance with the resize policy.

    map.shrink_to(50);
    assert!(map.capacity() >= 50);

    // Shrinks the capacity of the map as much as possible. It will drop
    // down as much as possible while maintaining the internal rules
    // and possibly leaving some space in accordance with the resize policy.
    map.shrink_to_fit();
    assert!(map.capacity() >= 2);
    println!("Success!");
}
```

## 4. [**Ownership**](https://practice.course.rs/collections/hashmap.html#ownership)
