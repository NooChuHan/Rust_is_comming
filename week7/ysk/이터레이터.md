반복자 패턴은 프로그래밍에서 일련의 아이템들을 순차적으로 처리할 수 있게 하는 구조이다. 이 패턴을 사용하면 개별 아이템에 접근하고 반복 로직을 처리하는 복잡한 코드를 작성할 필요 없이 효율적으로 데이터를 순회할 수 있다. 

특히 러스트 언어에서 반복자는 **"게으른(lazy)" 실행을 특징**으로 한다. 즉, 실제로 필요할 때까지 데이터 처리가 이루어지지 않고, 반복자에 대한 연산이 호출되면 그때 데이터가 처리됨.

### 반복자의 생성과 사용

러스트에서는 다음과 같이 `vec![1, 2, 3]` 벡터에 `iter()` 메서드를 호출하여 반복자를 생성할 수 있다.

```rust
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
```

생성된 반복자는 `for` 루프와 같은 반복 구조를 통해 소비될 때까지 아무런 작업도 수행하지 않는다.

이를 통해 개발자는 반복 처리를 위한 복잡한 코드를 직접 관리하지 않아도 되며, 반복자 내부의 `next()` 메서드를 호출하여 순차적으로 요소를 처리할 수 있다.

### 반복자의 특성과 메서드

반복자는 러스트의 `Iterator` 트레이트를 구현하며, 이 트레이트는 반복자가 처리할 각 아이템의 타입을 정의하는 `Item` 연관 타입과, 아이템을 하나씩 반환하는 `next()` 메서드를 요구한다.

```rust
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

`next()` 메서드는 반복자의 상태를 변경하여, 반복자가 현재 시퀀스의 어디에 있는지를 추적한다.

### 반복자를 소비하는 메서드

반복자는 다양한 "소비 어댑터" 메서드를 통해 소비될 수 있다. 

예를 들어, `sum()` 메서드는 반복자가 가진 모든 요소를 순회하며 합산하는 작업을 수행하고, 이 작업이 완료되면 반복자는 더 이상 사용할 수 없다.

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    let total: i32 = v1_iter.sum();
    assert_eq!(total, 6);
}
```

**`collect()` 메서드**

`collect()` 메서드는 반복자를 소비하고, 반복자가 생성하는 **요소들을** **어떤 컬렉션에 모아서 반환**합니다.

이를 통해 벡터, 해시맵, 세트 등 다양한 데이터 구조로 데이터를 변환할 수 있다.

```rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

`collect()` 메서드는 반복자 어댑터와 함께 사용되어, 데이터 변환 작업 후 변환된 결과를 실제 데이터 구조로 저장할 때 유용하다.


### 환경을 캡처하는 클로저

일부 반복자 어댑터는 클로저를 사용하여 외부 환경의 값을 "캡처"할 수 있다. 


```rust
fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
```
